// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.1
// source: payment/payment.proto

/* eslint-disable */
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { PaginationMeta } from "../common/basic";
import { BasicQuery } from "../common/basic-query";
import { SuccessResponse } from "../common/response";

export const protobufPackage = "payment";

export enum DepositStatus {
  APPLIED_STATUS_UNSPECIFIED = 0,
  PENDING = 1,
  APPROVED = 2,
  REJECTED = 3,
  UNRECOGNIZED = -1,
}

export interface Deposit {
  id: string;
  userId: string;
  walletId: string;
  depositedAmount?: string | undefined;
  beforeAmount?: string | undefined;
  status: DepositStatus;
  createdAt: string;
  updatedAt: string;
}

export interface Wallet {
  id: string;
  userId: string;
  balance: string;
  createdAt: string;
  updatedAt: string;
  deposits: Deposit[];
}

export interface CreatePaymentRequest {
  userId: string;
  depositedAmount: string;
}

export interface CreatePaymentResponse {
  message?: string | undefined;
  checkoutUrl: string;
}

export interface GetAllWalletsRequest {
  basicQuery: BasicQuery | undefined;
}

export interface AllWalletsWithMetaResponse {
  data: Wallet[];
  meta: PaginationMeta | undefined;
}

export interface ConfirmPaymentRequest {
  orderId: string;
  paymentKey: string;
  amount: string;
}

export interface FailPaymentRequest {
  code: string;
  message: string;
  orderId: string;
}

/** Request to prepare for a payment */
export interface PrepareDepositRequest {
  userId: string;
  /** Use int64 for money */
  amount: number;
  orderName: string;
  /** From your Deposit model */
  depositeName: string;
  userEmail: string;
  userPhone: string;
}

/** Response containing the data needed for the client to redirect to Toss */
export interface PrepareDepositResponse {
  tossOrderId: string;
  amount: number;
  /** The userId */
  customerKey: string;
  /** If using the checkout method */
  checkoutUrl: string;
}

/** Response after confirmation and execution */
export interface ConfirmPaymentResponse {
  success: boolean;
  transactionId: string;
  /** Can include the updated wallet balance here */
  message: string;
}

/** Request to handle payment failure (optional) */
export interface HandlePaymentFailureRequest {
  orderId: string;
  errorCode: string;
  errorMessage: string;
}

export interface HandlePaymentFailureResponse {
  success: boolean;
  message: string;
}

export const PAYMENT_PACKAGE_NAME = "payment";

export interface PaymentServiceClient {
  /** 1. Called by API Gateway to initiate the deposit/payment flow */

  prepareDeposit(request: PrepareDepositRequest): Observable<PrepareDepositResponse>;

  /** 2. Called by API Gateway after a successful redirect from Toss Payments */

  verifyAndExecutePayment(request: ConfirmPaymentRequest): Observable<ConfirmPaymentResponse>;

  /** 3. Optional: Called by API Gateway after a failed redirect from Toss Payments */

  handlePaymentFailure(request: HandlePaymentFailureRequest): Observable<HandlePaymentFailureResponse>;

  getAllWallets(request: GetAllWalletsRequest): Observable<AllWalletsWithMetaResponse>;

  createPayment(request: CreatePaymentRequest): Observable<CreatePaymentResponse>;

  confirmPayment(request: ConfirmPaymentRequest): Observable<SuccessResponse>;

  failPayment(request: FailPaymentRequest): Observable<SuccessResponse>;
}

export interface PaymentServiceController {
  /** 1. Called by API Gateway to initiate the deposit/payment flow */

  prepareDeposit(
    request: PrepareDepositRequest,
  ): Promise<PrepareDepositResponse> | Observable<PrepareDepositResponse> | PrepareDepositResponse;

  /** 2. Called by API Gateway after a successful redirect from Toss Payments */

  verifyAndExecutePayment(
    request: ConfirmPaymentRequest,
  ): Promise<ConfirmPaymentResponse> | Observable<ConfirmPaymentResponse> | ConfirmPaymentResponse;

  /** 3. Optional: Called by API Gateway after a failed redirect from Toss Payments */

  handlePaymentFailure(
    request: HandlePaymentFailureRequest,
  ): Promise<HandlePaymentFailureResponse> | Observable<HandlePaymentFailureResponse> | HandlePaymentFailureResponse;

  getAllWallets(
    request: GetAllWalletsRequest,
  ): Promise<AllWalletsWithMetaResponse> | Observable<AllWalletsWithMetaResponse> | AllWalletsWithMetaResponse;

  createPayment(
    request: CreatePaymentRequest,
  ): Promise<CreatePaymentResponse> | Observable<CreatePaymentResponse> | CreatePaymentResponse;

  confirmPayment(
    request: ConfirmPaymentRequest,
  ): Promise<SuccessResponse> | Observable<SuccessResponse> | SuccessResponse;

  failPayment(request: FailPaymentRequest): Promise<SuccessResponse> | Observable<SuccessResponse> | SuccessResponse;
}

export function PaymentServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "prepareDeposit",
      "verifyAndExecutePayment",
      "handlePaymentFailure",
      "getAllWallets",
      "createPayment",
      "confirmPayment",
      "failPayment",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("PaymentService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("PaymentService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PAYMENT_SERVICE_NAME = "PaymentService";
